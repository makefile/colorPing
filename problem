2014年 08月 14日 星期五 18:58:33 CST
vi中:r!date产生时间
main函数中先发??完4个包再开始接?收包有时间差，??如果发最后一个包时系统繁忙发不出去?，则接??再接收就太迟了?，统计不准确??。
或许运用多线程。多进程。

2014年 08月 15日 星期五 19:05:37 CST
修改如下：
1.在发包的函数中调用接收函数
2.增加对中断信号的捕捉
3.发包函数放到新线程中执行，但此时没有必要
bug:
时间统计不准确
欲添加功能:
支持命令行选项，如-c 4制定发送数据包的个数
最终目标：
更改可执行程序的用户为root，setuid：普通用户即可执行
移到标准目录，或设置环境变量。
制作deb等安装包，写安装配置脚本。
编写新版程序，利用新内核的对ICMP的便利支持，可能需要自己配置内核参数，可写入安装脚本自动修改。
体会：
今天代码改动较大，且并未做备份，还未用过版本控制工具git,svn等，有机会的时候一定要学一学，不然永远也难想参与大项目。

2014年 08月 17日 星期日 12:38:30 CST
我现在彻底凌乱了！关于sys/time.h中的gettimeofday(struct timeval*,struct timezone*),获取当前时间并赋值给两个结构体，但是实验发现如果第二个参数传入NULL，并用printf("%d"的形式打印timeval的秒数和微秒数，打印之后立刻段错误。%lf形式结果直接是0，并无段错误，多次运行程序发现timeval的值更本不变只有timezone的值在改变。再次以%lld（我目前使用32位系统，gcc4.8）形式打印发现有了可喜变化。我不晓得那个__time_t到底有多大。
另外我想time.h应该是ASCII的标准库而sys/time.h是POSIX标准
目前的ping程序运行总是50%丢包。
2014年 08月 18日 星期一 18:49:24 CST
今天遇到的问题：
用memset或bzero对struct icmp的一个结构体初始零值，但程序在此处直接退出，返回值139,让我浪费了很久时间，由于我头脑发急，没有仔细考虑，甚至认为这两个初始化函数的返回值不合理（NULL，或NULL*）。后来才发现我根本就没有给icmp数组分配空间，给一个野指针对应的空间初始化当然会遭到操作系统的无情砍杀。但是太悄然无声了，也没有段错误。还有今天使用gdb才发现电脑上竟然没有装着，由于是刚安装不久的ubuntu14.04系统我以为安装了build-essential就自带了，现在网络不方便。没有了gdb就多了些print.
修改情况：
将时间作为icmp数据包的数据内容的语句修正，原来的是严重bug。时间月就越发现自己C语言能力还差的很。
命令行参数选项仍然未能搞定。发包和收包的时间顺序及逻辑不知怎么办，恐怕得看PING的源码了。
没有网络这些问题难道就解决不了了吗?
2014年 08月 31日 星期日 22:02:20 CST
今日阅读了ping的源码(1989年的)，源码并是很长，但是自己很多还理解不了，许多的系统api都没见过。主要是看它的逻辑，很多的命令行选项的组织形式。发现的确是发一个包后立即接受。上网查了一些源码，发现书上的代码像是抄袭的，相似度99%，那在2001年的IBM网站上。
发现了许多逻辑上的错误，如暂停1秒与收包函数的先后顺序反了，怪不得rtt（也许是return time的缩写）一直是0。将reply的包中的data区域读出时间当做发送时的时间，
